@page "/"
@using Blazor.Client.Widgets
@using Blazor.Core
@using Blazor.Core.Widgets
@inject IWidgetFactory factory
@implements IDisposable

<h1>Hail to the widgetised Blazor!</h1>
A widget can be created <strong>in-line</strong> as a part of Blazor UI or dynamically built on the fly <strong>in a container</strong>.

<h3>Inline widget</h3>
<p>TODO</p>

<h3>Widget container</h3>
<ContainerComponent Key="@DELAYED_CONTAINER">
    This content will be <strong>filled in @seconds seconds</strong> with <i>RandomUpdator</i> widget.
</ContainerComponent>

<h3>Child component</h3>
<LinkToGitHub Title="Do you want to know more?" />

@functions
{
    private const string DELAYED_CONTAINER = "DELAYED_CONTAINER";

    private int seconds = 5;
    private bool isRepeatedRender;
    private bool isDisposed;

    public void Dispose()
    {
        isDisposed = true;
    }

    protected override Task OnAfterRenderAsync()
    {
        if (isRepeatedRender)
        {
            return Task.FromResult(0);
        }

        isRepeatedRender = true;

        #pragma warning disable 4014
        CountDownAsync();
        #pragma warning restore 4014
        return ExampleOfManualyCreatedWidget();
    }

    async Task ExampleOfManualyCreatedWidget()
    {
        await Task.Delay(5000);

        if (isDisposed)
        {
            return;
        }

        // Manual activation of widget
        object mediator = factory.Build(WidgetVariants.SHOW_WIDGET);
        IActivatable<string> activatable = (IActivatable<string>)mediator;
        activatable.Activate(DELAYED_CONTAINER);
    }

    // Update of count down in widget container
    private async Task CountDownAsync()
    {
        do
        {
            await Task.Delay(1000);

            if (isDisposed)
            {
                return;
            }

            seconds--;
            StateHasChanged();
        } while (seconds > 0);
    }
}
